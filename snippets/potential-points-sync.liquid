{% comment %}
  Syncs potential loyalty points FROM section app block (order-placed-potential-points-amount)
  INTO main-product app block. Uses section value as source of truth (e.g. after country change).
  LOCAL CHECK: Inspect the #loy-potential-points inside the product info (price area) â€”
  class "loyalty-points-synced" = script ran; data-potential-points-value = number used.
{% endcomment %}
<script>
  (function() {
    function getPotentialPointsValue() {
      var allSpans = document.querySelectorAll('span.order-placed-potential-points-amount');
      var mainProduct = document.querySelector('[id^="MainProduct-"]');
      var value = null;
      var fromSection = null;
      for (var i = 0; i < allSpans.length; i++) {
        var text = (allSpans[i].textContent || '').trim();
        if (text && !isNaN(parseInt(text, 10))) {
          if (mainProduct && !mainProduct.contains(allSpans[i])) {
            fromSection = text;
            break;
          }
          if (!value) value = text;
        }
      }
      return fromSection !== null ? fromSection : value;
    }

    function replacePotentialPointsInProductInfo() {
      var pointsValue = getPotentialPointsValue();
      var productInfo = document.querySelector('[id^="ProductInfo-"]');
      if (!productInfo) return false;
      var container = productInfo.querySelector('#loy-potential-points') || productInfo.querySelector('#potential-points-text');
      if (!container) return false;

      if (!pointsValue) {
        container.classList.remove('loyalty-points-synced');
        container.removeAttribute('data-potential-points-value');
        container.classList.add('loyalty-points-not-synced');
        return false;
      }

      var didSomething = false;

      function hasPlaceholder(str) {
        return str.indexOf('[potential_points]') !== -1 || str.indexOf('[puntos_potenciales]') !== -1;
      }
      function replacePlaceholders(str) {
        return str.replace(/\[potential_points\]/g, pointsValue).replace(/\[puntos_potenciales\]/g, pointsValue);
      }
      function walkReplaceText(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          if (hasPlaceholder(node.textContent)) {
            node.textContent = replacePlaceholders(node.textContent);
            return true;
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.classList && node.classList.contains('order-placed-potential-points-amount')) {
            var current = (node.textContent || '').trim();
            if (current !== pointsValue && (current === '' || current === '[potential_points]' || current === '[puntos_potenciales]' || !isNaN(parseInt(current, 10)))) {
              node.textContent = pointsValue;
              didSomething = true;
            }
            return false; // don't walk into span children
          }
          if (node.childNodes) {
            for (var j = 0; j < node.childNodes.length; j++) {
              if (walkReplaceText(node.childNodes[j])) didSomething = true;
            }
          }
        }
        return false;
      }
      walkReplaceText(container);

      container.classList.add('loyalty-points-synced');
      container.classList.remove('loyalty-points-not-synced');
      container.setAttribute('data-potential-points-value', pointsValue);
      return true;
    }

    function syncPotentialPoints() {
      replacePotentialPointsInProductInfo();
    }

    function run() {
      syncPotentialPoints();
      setTimeout(syncPotentialPoints, 800);
      setTimeout(syncPotentialPoints, 2000);
      setTimeout(syncPotentialPoints, 4000);
      setTimeout(syncPotentialPoints, 6000);
      setTimeout(syncPotentialPoints, 8000);
      setTimeout(syncPotentialPoints, 12000);
      if (typeof MutationObserver !== 'undefined') {
        var syncTimer = null;
        var observer = new MutationObserver(function(mutations) {
          for (var m = 0; m < mutations.length; m++) {
            var mut = mutations[m];
            if (mut.addedNodes && mut.addedNodes.length) {
              if (!syncTimer) syncTimer = setTimeout(function() { syncTimer = null; syncPotentialPoints(); }, 500);
              break;
            }
            if (mut.type === 'characterData' || (mut.target.classList && mut.target.classList.contains('order-placed-potential-points-amount'))) {
              if (!syncTimer) syncTimer = setTimeout(function() { syncTimer = null; syncPotentialPoints(); }, 500);
              break;
            }
          }
        });
        observer.observe(document.body, { childList: true, subtree: true, characterData: true, characterDataOldValue: true });
        setTimeout(function() { observer.disconnect(); }, 20000);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', run);
    } else {
      run();
    }
  })();
</script>
