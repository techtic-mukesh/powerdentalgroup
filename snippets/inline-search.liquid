<!-- UPDATED PREDICTIVE SEARCH WITH EXACT SKU MATCHING -->
<div class="header__search-inline">
  <form action="{{ routes.search_url }}" method="get" role="search" class="search-form" autocomplete="off">
    <input
      type="search"
      name="q"
      id="Search-Inline"
      placeholder="Find products by name or SKU"
      class="search-input"
      value="{{ search.terms | escape }}"
      role="combobox"
      aria-expanded="false"
      aria-owns="PredictiveResults"
      aria-controls="PredictiveResults"
      aria-autocomplete="list"
      aria-haspopup="listbox"
    >
    <button type="submit" class="search-btn search-icon" aria-label="Search">
      {% render 'icon-search' %}
    </button>
    <button type="button" class="search-btn close-icon" aria-label="Clear Search">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M21 21L12 12M12 12L3 3M12 12L21.0001 3M12 12L3 21.0001" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </form>
</div>
<div id="PredictiveResultsoverlay" bis_skin_checked="1"></div>
<div id="PredictiveResults" class="predictive-search-results"></div>

<style>
.header__search-inline {
    flex-grow: 1;
    position: relative;
    max-width: 453px;
}

.header__search-inline input#Search-Inline {
    width: 100%;
    height: 42px;
    border-radius: 3000px;
    border: 1px solid #DCDCDC;
    background: #FFF;
    padding: 0 50px 0 20px;
    color: #131313;
    font-family: Prompt;
    font-size: 14px;
    font-style: normal;
    font-weight: 300;
    line-height: 14px;
    box-sizing: border-box;
}

.header__search-inline button.search-btn {
    background: unset;
    border: unset;
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    cursor: pointer;
}

.header__search-inline input#Search-Inline::placeholder {
    color: #131313;
    font-family: Prompt;
    font-size: 14px;
    font-style: normal;
    font-weight: 300;
    line-height: 14px;
}

div#PredictiveResults {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    background-color: #fff;
    max-width: 900px;
    margin: 0 auto;
    left: 50%;
    transform: translateX(-50%);
    border-radius: unset;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    z-index: 1000;
    display: none;
}

div#PredictiveResults.show {
    display: block;
}

/* Two Column Layout */
.search-results-container {
    display: flex;
    min-height: 400px;
}

.products-section {
    flex: 1;
    border-right: 1px solid #e5e5e5;
}

.suggestions-section {
    width: 200px;
    background-color: #fafafa;
    padding: 20px;
}

#PredictiveResults .section-header {
    padding: 15px 20px;
    border-bottom: 1px solid #e5e5e5;
    font-weight: 600;
    color: #141132;
    font-size: 19px;
    line-height: 24px;
    box-shadow: unset;
}

.suggestions-section h3 {
    margin: 0 0 10px 0;
    font-weight: 600;
    color: #141132;
    font-size: 14px;
    line-height: 24px;
    padding-bottom: 10px;
    border-bottom: 1px solid #66666647;
}

/* Products List */
div#PredictiveResults ul.predictive-list {
    margin: 0;
    height: 350px;
    overflow-y: auto;
    padding: 0;
    background-color: #fff;
}

div#PredictiveResults ul.predictive-list li {
    list-style: none;
    border-bottom: 1px solid #f0f0f0;
}

div#PredictiveResults ul.predictive-list li:last-child {
    border-bottom: none;
}

div#PredictiveResults ul.predictive-list a.predictive-item {
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px 20px;
    transition: background-color 0.2s ease;
}

div#PredictiveResults ul.predictive-list a.predictive-item:hover {
    background-color: #f8f9fa;
}

div#PredictiveResults ul.predictive-list a.predictive-item img {
    width: 75px;
    height: 75px;
    min-width: 60px;
    object-fit: contain;
    border-radius: 8px;
    background-color: #fff;
}

div#PredictiveResults ul.predictive-list a.predictive-item span.product-title {
    color: #141132;
    font-family: Montserrat;
    font-size: 14px;
    font-style: normal;
    font-weight: 600;
    line-height: 20px;
    margin: 0 0 5px 0;
    display: block;
}

.predictive-info p.product-price {
    font-variant-numeric: ordinal;
    font-family: Montserrat;
    font-size: 16px;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    margin: 0;
    background: linear-gradient(90deg, #42C5EF 0%, #0033A0 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.product-meta {
    font-size: 12px;
    color: #666;
    margin-top: 2px;
    font-family: Montserrat;
}

/* Exact SKU Match Styling */
div#PredictiveResults ul.predictive-list li.exact-sku-match {
    background-color: #f0f8ff;
    border-left: 3px solid #007acc;
}

div#PredictiveResults ul.predictive-list li.exact-sku-match a.predictive-item {
    background-color: #f0f8ff;
}

div#PredictiveResults ul.predictive-list li.exact-sku-match:hover a.predictive-item {
    background-color: #e6f3ff;
}

.sku-match-indicator {
    font-size: 0.8em;
    color: #007acc;
    font-weight: bold;
    margin-top: 2px;
    display: none;
}

.sku-match-indicator.exact {
    color: #0066cc;
    font-weight: 700;
    display: none;
}

/* Suggestions List */
.suggestions-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.suggestions-list li {
    margin-bottom: 12px;
}

.suggestions-list a {
    text-decoration: none;
    transition: color 0.2s ease;
    color: #141132;
    font-family: Prompt;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 22px;
}

.suggestions-list a:hover {
    color: #0033A0;
}

/* Close Icon */
.header__search-inline button.search-btn.close-icon svg {
    width: 15px;
    height: 17px;
}

.header__search-inline input[type="search"]::-webkit-search-cancel-button {
    display: none;
}

.header__search-inline button.search-btn.close-icon {
    display: none;
    cursor: pointer;
}

/* No Results */
.no-results {
    padding: 40px 20px;
    text-align: center;
    color: #141132;
}

/* Loading State */
.loading-state {
    padding: 40px 20px;
    text-align: center;
    color: #141132;
}

/* View All Link */
.view-all-container {
    padding: 15px 20px;
    text-align: center;
    border-top: 1px solid #e5e5e5;
    background-color: #fafafa;
}

.view-all-link {
    color: #0033A0;
    font-family: Montserrat;
    font-size: 14px;
    font-style: normal;
    font-weight: 600;
    line-height: normal;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 5px;
    transition: color 0.2s ease;
}

.view-all-link:hover {
    color: #42C5EF;
}

div#PredictiveResultsoverlay {
    position: fixed;
    width: 100%;
    height: 100%;
    display: none;
    left: 0;
    top: 0;
    z-index: -1;
    background: rgba(20, 17, 50, 0.70);
    backdrop-filter: blur(1.5px);
}

.sp-circle {
    border: 3.6px rgba(0, 0, 0, 0.25) solid;
    border-top: 3.6px #0033A0  solid;
    border-radius: 50%;
    -webkit-animation: spCircRot 0.6s infinite linear;
    animation: spCircRot 1s infinite linear;
    width: 32px;
    height: 32px;
    clear: both;
    margin: 20px auto;
    display: flex !important;
}

body.gradient.predictive-show .header--middle-left .header__inline-menu ul.list-menu.list-menu--inline {
    pointer-events: none;
}

@keyframes spCircRot {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(359deg);
    }
}

@media only screen and (max-width: 990px) {
    .header__search-inline {
        max-width: 100%;
    }
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .search-results-container {
        flex-direction: column;
    }
    
    .suggestions-section {
        width: 100%;
        border-right: none;
        border-top: 1px solid #e5e5e5;
    }
    
    div#PredictiveResults {
        max-width: 100%;
        left: 0;
        transform: none;
        margin: 0;
    }
}
</style>

<script>
class PredictiveSearch {
    constructor() {
        this.input = document.querySelector('#Search-Inline');
        this.results = document.querySelector('#PredictiveResults');
        this.overlay = document.querySelector('#PredictiveResultsoverlay');
        this.searchIcon = document.querySelector('.search-icon');
        this.closeIcon = document.querySelector('.close-icon');
        
        // Debounce timer
        this.debounceTimer = null;
        
        this.input.addEventListener('input', this.onChange.bind(this));
        this.closeIcon.addEventListener('click', this.clearSearch.bind(this));
        
        // Hide results when clicking outside or on overlay
        document.addEventListener('click', this.handleOutsideClick.bind(this));
        if (this.overlay) {
            this.overlay.addEventListener('click', this.hideResults.bind(this));
        }
    }

    onChange() {
        const query = this.input.value.trim();
        
        // Toggle icons
        if (query !== '') {
            this.searchIcon.style.display = 'none';
            this.closeIcon.style.display = 'flex';
        } else {
            this.searchIcon.style.display = 'flex';
            this.closeIcon.style.display = 'none';
        }

        // Clear previous timer
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }

        if (query.length < 2) {
            this.hideResults();
            return;
        }

        // Show loading state
        this.showLoading();

        // Debounce the API call
        this.debounceTimer = setTimeout(() => {
            this.fetchResults(query);
        }, 300);
    }

    // Fetch detailed product info including SKU
    async fetchProductDetails(productHandle) {
        try {
            const response = await fetch(`/products/${productHandle}.js`);
            const productData = await response.json();
            return productData;
        } catch (error) {
            console.error('Error fetching product details:', error);
            return null;
        }
    }

    async fetchResults(query) {
        // Product search by title and SKU fields
        const productPromise = fetch(
            `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=product&resources[limit]=12&resources[options][fields]=title,body,product_type,variants.sku,vendor&section_id=predictive-search`
        )
        .then(response => response.json())
        .then(async data => {
            let products = data.resources?.results?.products || [];
            
            // If no results from title search, try SKU-specific search
            if (products.length === 0) {
                products = await this.searchBySKU(query);
            }
            
            // Fetch detailed product info for each product to get accurate SKU
            const productsWithDetails = await Promise.all(
                products.map(async product => {
                    const handle = product.url.split('/products/')[1]?.split('?')[0];
                    if (handle) {
                        const details = await this.fetchProductDetails(handle);
                        if (details) {
                            product.fullDetails = details;
                        }
                    }
                    return product;
                })
            );
            
            return productsWithDetails;
        });

        const collectionPromise = fetch(
            `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=collection&resources[limit]=4&section_id=predictive-search`
        )
        .then(response => response.json())
        .then(data => data.resources?.results?.collections || []);

        const queryPromise = fetch(
            `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=query&resources[limit]=4&section_id=predictive-search`
        )
        .then(response => response.json())
        .then(data => data.resources?.results?.queries || []);

        // Fetch the actual total count from the search results page
        const totalCountPromise = this.fetchTotalResultCount(query);

        Promise.all([productPromise, collectionPromise, queryPromise, totalCountPromise])
            .then(([products, collections, queries, totalCount]) => {
                // SORT PRODUCTS BY SKU RELEVANCE
                const sortedProducts = this.sortProductsBySKURelevance(products, query);
                this.renderResults(sortedProducts, collections, queries, query, totalCount);
            })
            .catch(error => {
                console.error('Search error:', error);
                this.showNoResults();
            });
    }

    // NEW METHOD: Sort products by SKU relevance
    sortProductsBySKURelevance(products, query) {
        const queryLower = query.toLowerCase().trim();
        
        return products.sort((a, b) => {
            const scoreA = this.calculateRelevanceScore(a, queryLower);
            const scoreB = this.calculateRelevanceScore(b, queryLower);
            return scoreB - scoreA;
        });
    }

    // NEW METHOD: Calculate relevance score
    calculateRelevanceScore(product, query) {
        let score = 0;
        
        // Get all SKUs from product
        const skus = [];
        if (product.fullDetails && product.fullDetails.variants) {
            product.fullDetails.variants.forEach(v => {
                if (v.sku) skus.push(v.sku.toLowerCase());
            });
        } else if (product.variants) {
            product.variants.forEach(v => {
                if (v.sku) skus.push(v.sku.toLowerCase());
            });
        }
        
        const title = (product.title || '').toLowerCase();
        
        // Scoring logic - Exact SKU match gets highest priority
        for (const sku of skus) {
            if (sku === query) {
                return 10000; // Exact SKU match - TOP PRIORITY
            }
            if (sku.startsWith(query)) {
                score = Math.max(score, 9000); // SKU starts with query
            }
            if (sku.includes(query)) {
                score = Math.max(score, 8000); // SKU contains query
            }
        }
        
        // Title matching (lower priority than SKU)
        if (title === query) {
            score = Math.max(score, 7000);
        } else if (title.startsWith(query)) {
            score = Math.max(score, 6000);
        } else if (title.includes(query)) {
            score = Math.max(score, 5000);
        }
        
        return score;
    }

    // New method to fetch total result count from search page
    async fetchTotalResultCount(query) {
        try {
            const response = await fetch(`/search?q=${encodeURIComponent(query)}&type=product`);
            const html = await response.text();
            
            // Parse the HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Try multiple selectors to find the result count
            // Method 1: Look for text containing "results found"
            const bodyText = doc.body.textContent;
            const patterns = [
                /(\d+)\s+results?\s+found/i,
                /(\d+)\s+results?/i,
                /found\s+(\d+)/i,
                /showing\s+.*?of\s+(\d+)/i
            ];
            
            for (const pattern of patterns) {
                const match = bodyText.match(pattern);
                if (match && match[1]) {
                    const count = parseInt(match[1]);
                    if (count > 0) {
                        return count;
                    }
                }
            }
            
            // Method 2: Try common Shopify theme selectors
            const selectors = [
                '.collection-product-count',
                '.results-count',
                '[data-results-count]',
                '.product-count',
                '.search-results-count',
                'h1.h2',
                '.collection-hero__title'
            ];
            
            for (const selector of selectors) {
                const element = doc.querySelector(selector);
                if (element) {
                    const text = element.textContent;
                    const match = text.match(/(\d+)/);
                    if (match) {
                        const count = parseInt(match[0]);
                        if (count > 0) {
                            return count;
                        }
                    }
                }
            }
            
            // Method 3: Count actual product grid items as fallback
            const productSelectors = [
                '.grid__item.product-card-wrapper',
                '.product-item',
                '[data-product-id]',
                '.product-grid-item',
                '.collection-product-card'
            ];
            
            for (const selector of productSelectors) {
                const items = doc.querySelectorAll(selector);
                if (items.length > 0) {
                    return items.length;
                }
            }
            
            return 0;
        } catch (error) {
            console.error('Error fetching total count:', error);
            return 0;
        }
    }

    // More accurate SKU-only fallback
    async searchBySKU(query) {
        try {
            const skuResponse = await fetch(
                `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=product&resources[limit]=12&resources[options][fields]=variants.sku&section_id=predictive-search`
            );
            const skuData = await skuResponse.json();
            return skuData.resources?.results?.products || [];
        } catch (err) {
            console.error('SKU search error:', err);
            return [];
        }
    }

    renderResults(products, collections, queries, originalQuery, totalCount = 0) {
        // Store query for view all link
        this.currentQuery = originalQuery;
        
        if (!products.length && !collections.length && !queries.length) {
            this.showNoResults();
            return;
        }

        const queryLower = originalQuery.toLowerCase().trim();

        // Build products HTML with SKU from Product API
        const productsHtml = products.length ? 
            products.slice(0, 6).map(product => {
                const price = product.price;
                const comparePrice = product.compare_at_price ? (product.compare_at_price / 100).toFixed(2) : null;
                const imageUrl = product.featured_image?.url ? product.featured_image.url : '/assets/product-placeholder.svg';
                
                // Get SKU from full product details (Product API)
                let productSKU = '';
                let allSKUs = [];
                
                if (product.fullDetails && product.fullDetails.variants) {
                    // Get all SKUs from the product
                    allSKUs = product.fullDetails.variants
                        .filter(v => v.sku)
                        .map(v => v.sku);
                    
                    // Get the first variant's SKU as primary
                    const primaryVariant = product.fullDetails.variants.find(v => v.sku) || product.fullDetails.variants[0];
                    productSKU = primaryVariant?.sku || '';
                } else if (product.variants && product.variants.length > 0) {
                    // Fallback to suggest API data
                    const variant = product.variants.find(v => v.sku) || product.variants[0];
                    productSKU = variant.sku || '';
                }
                
                // Check if exact SKU match or partial match
                const isExactSkuMatch = allSKUs.some(sku => 
                    sku.toLowerCase() === queryLower
                ) || (productSKU && productSKU.toLowerCase() === queryLower);
                
                const isSkuMatch = allSKUs.some(sku => 
                    sku.toLowerCase().includes(queryLower)
                ) || (productSKU && productSKU.toLowerCase().includes(queryLower));
                
                // Display multiple SKUs if available
                const skuDisplay = allSKUs.length > 1 
                    ? `${productSKU} ${allSKUs.length > 1 ? `(+${allSKUs.length - 1} more)` : ''}`
                    : productSKU;
                
                // Determine match indicator
                let matchIndicator = '';
                if (isExactSkuMatch) {
                    matchIndicator = '<div class="sku-match-indicator exact">✓ Exact SKU Match</div>';
                } else if (isSkuMatch) {
                    matchIndicator = '<div class="sku-match-indicator">✓ SKU Match</div>';
                }
                
                return `
                    <li class="${isExactSkuMatch ? 'exact-sku-match' : ''}">
                        <a href="${product.url}" class="predictive-item">
                            <img src="${imageUrl}" alt="${product.featured_image?.alt || product.title}" loading="lazy" />
                            <div class="predictive-info">
                                <span class="product-title">${product.title}</span>
                                <p class="product-price">
                                    $${price}
                                    ${comparePrice && comparePrice !== price ? `<span class="compare-price" style="text-decoration: line-through; color: #999; margin-left: 8px;">$${comparePrice}</span>` : ''}
                                </p>
                                ${productSKU ? `<div class="product-sku" style="font-size: 0.85em; color: #666; margin: 4px 0 2px 0;">SKU: ${skuDisplay}</div>` : ''}
                                ${matchIndicator}
                            </div>
                        </a>
                    </li>
                `;
            }).join('') : '<li class="no-results" style="padding: 20px;">No products found</li>';

        // Build suggestions HTML
        const suggestions = [];
        
        // Add collections as suggestions
        if (collections.length) {
            collections.forEach(collection => {
                suggestions.push({
                    title: collection.title,
                    url: collection.url,
                    type: 'collection'
                });
            });
        }

        // Add query suggestions
        if (queries.length) {
            queries.forEach(query => {
                suggestions.push({
                    title: query.styled_text || query.text,
                    url: `/search?q=${encodeURIComponent(query.text)}`,
                    type: 'query'
                });
            });
        }

        // Add popular searches if no other suggestions
        if (!suggestions.length) {
            const popularSearches = ['new arrivals', 'sale', 'accessories', 'featured'];
            popularSearches.forEach(term => {
                if (term.toLowerCase().includes(originalQuery.toLowerCase())) {
                    suggestions.push({
                        title: term,
                        url: `/search?q=${encodeURIComponent(term)}`,
                        type: 'popular'
                    });
                }
            });
        }

        const suggestionsHtml = suggestions.length ?
            suggestions.slice(0, 6).map(suggestion => `
                <li><a href="${suggestion.url}">${suggestion.title}</a></li>
            `).join('') : '<li style="color: #999; font-style: italic;">No suggestions</li>';

        // Build the "View all" text with count - show actual total from search page
        const viewAllText = totalCount > 0 
            ? `View all ${totalCount} result${totalCount !== 1 ? 's' : ''} →`
            : 'View all results →';

        this.results.innerHTML = `
            <div class="search-results-container">
                <div class="products-section">
                    <div class="section-header">Products</div>
                    <ul class="predictive-list">
                        ${productsHtml}
                    </ul>
                    <div class="view-all-container">
                        <a href="/search?q=${encodeURIComponent(originalQuery)}" class="view-all-link">
                            ${viewAllText}
                        </a>
                    </div>
                </div>
                <div class="suggestions-section">
                    <h3>Suggestions</h3>
                    <ul class="suggestions-list">
                        ${suggestionsHtml}
                    </ul>
                </div>
            </div>
        `;
        
        this.showResults();
    }

    showLoading() {
        this.results.innerHTML = `
            <div class="loading-state">
               <div class="sp sp-circle"></div>
            </div>
        `;
        this.showResults();
    }

    showNoResults() {
        this.results.innerHTML = '<p class="no-results">No results found for products or SKUs</p>';
        this.showResults();
    }

    showResults() {
        this.results.classList.add('show');
        if (this.overlay) {
            this.overlay.style.display = 'inline-block';
        }
        document.body.classList.add('predictive-show');
    }

    hideResults() {
        this.results.classList.remove('show');
        if (this.overlay) {
            this.overlay.style.display = 'none';
        }
        document.body.classList.remove('predictive-show');
    }

    clearSearch() {
        this.input.value = '';
        this.input.focus();
        this.searchIcon.style.display = 'flex';
        this.closeIcon.style.display = 'none';
        this.hideResults();
        
        // Clear debounce timer
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }
    }

    handleOutsideClick(e) {
        const searchContainer = document.querySelector('.header__search-inline');
        const results = document.querySelector('#PredictiveResults');
        
        if (!searchContainer.contains(e.target) && !results.contains(e.target)) {
            this.hideResults();
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new PredictiveSearch();
});
</script>